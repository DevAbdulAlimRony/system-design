# RDBMS: A relational database management system (RDBMS) is a program used to create, update, and manage relational databases. 
Some of the most well-known RDBMSs engines include MySQL, PostgreSQL, MariaDB, Microsoft SQL Server, and Oracle Database.

ACID is a set of properties of relational database transactions:

    Atomicity - The "all or nothing" rule. If a transaction has five steps and the fourth one fails, the whole thing is canceled. No partial data is saved.
    Consistency - The database must follow all its own rules (like unique IDs or data types). A transaction can only take the database from one valid state to another. Exmp: The total amount of money in both accounts combined must stay the same.
    Isolation - EEven if 1,000 people are using the database at the same time, their transactions shouldn't mess with each other. It's as if they were running sequentially.
    Durability - Once the system tells you a transaction is "committed" (saved), it’s permanent. Even if the server crashes five seconds later, the data is safe.

# RDMBS Scaling:
1. Master Slave Replication: 
The master serves reads and writes, replicating writes to one or more slaves, which serve only reads. 
Slaves can also replicate to additional slaves in a tree-like fashion. 
If the master goes offline, the system can continue to operate in read-only mode until a slave is promoted to a master or a new master is provisioned.
Disadvantage: need additional logic to promote from slave to master.

2. Master Master Replication: 
Both masters serve reads and writes and coordinate with each other on writes.
If either master goes down, the system can continue to operate with both reads and writes.
Multi-master replication is a method of database replication which allows data to be stored by a group of computers, and updated by any member of the group. 
Disadvantages: Need load balancer or make change in logic, conflict resolution problem

Replication Problems in common:
There is a potential for loss of data if the master fails before any newly written data can be replicated to other nodes.
Writes are replayed to the read replicas. If there are a lot of writes, the read replicas can get bogged down with replaying writes and can't do as many reads.
The more read slaves, the more you have to replicate, which leads to greater replication lag.
Replication adds more hardware and additional complexity.

3. Federation:
Instead of a single, monolithic database, you could have three databases: forums, users, and products, resulting in less read and write traffic to each database and therefore less replication lag. 
Smaller databases result in more data that can fit in memory, which in turn results in more cache hits due to improved cache locality. 
With no single central master serializing writes you can write in parallel, increasing throughput.
Disadvantage: Not efficiency if schema requres huge functions or tables, changes in application logic to determine which database to read and write, joining data from two databases is more complex wih a server link, more hardware and complexity.

4. Sharding:
Sharding is a method for scaling databases horizontally by partitioning data across multiple servers.
When a single database can no longer handle the volume of data or requests, sharding distributes the load.
Sharding distributes data across different databases such that each database can only manage a subset of the data. 
Sharding results in less read and write traffic, less replication, and more cache hits. 
Index size is also reduced, which generally improves performance with faster queries.
If one shard goes down, the other shards are still operational, although you'll want to add some form of replication to avoid data loss. 
Common ways to shard a table of users is either through the user's last name initial or the user's geographic location.
Disadvantages: need to update business logic with complex SQL queries, rebalancing complexity, joining data from multiple shards, adds more hardware and complexity. 

5. Denormalization:
Denormalization attempts to improve read performance at the expense of some write performance.
Redundant copies of the data are written in multiple tables to avoid expensive joins.
Some RDBMS such as PostgreSQL and Oracle support materialized views which handle the work of storing redundant information and keeping redundant copies consistent.
When we use federation or sharding, joining becomes complex, so we can use denormalization there.
Disadvantage: Data is duplicated, complexity of database design, write operation can be heavy.

6. SQL Tuning: 
Benchmark - Simulate high-load situations with tools such as ab.
Profile - Enable tools such as the slow query log to help track performance issues.
- Use CHAR instead of VARCHAR for fixed-length fields. CHAR effectively allows for fast, random access, whereas with VARCHAR, you must find the end of a string before moving onto the next one.
- Use TEXT for large blocks of text such as blog posts.
- Use INT for larger numbers up to 2^32 or 4 billion.
- Use DECIMAL for currency to avoid floating point representation errors.
- Avoid storing large BLOBS, store the location of where to get the object instead.
- VARCHAR(255) is the largest number of characters that can be counted in an 8 bit number, often maximizing the use of a byte in some RDBMS.
- Set the NOT NULL constraint where applicable to improve search performance.
- Columns to query by select, group by, order by, join  could be faster with indices. (plural of index)
- Placing an index can keep the data in memory, requiring more space.
- Writes could also be slower since the index also needs to be updated.
- When loading large amounts of data, it might be faster to disable indices, load the data, then rebuild the indices.
- Avoid expensive joins.
- Break up a table by putting hot spots in a separate table to help keep it in memory.
- In some cases, the query cache could lead to performance issues, Tune the query cache.

## NoSQL:
High-level system design, NoSQL (Not Only SQL) refers to a broad category of database management systems designed to handle diverse data models—like documents, graphs, 
and key-value pairs—that don't fit into the rigid rows and columns of traditional relational databases (RDBMS).

Move toward NoSQL when your design requirements hit these specific walls:
A. Extreme Horizontal Scalability:
   Relational databases are typically "Vertical" (you need a bigger, more expensive server). NoSQL is designed to be "Horizontal" (you just add more cheap servers).
   When: When your traffic grows from thousands to millions of concurrent users and a single server can no longer handle the load.

B. Schema Flexibility (Unstructured Data)
   If your data doesn't have a fixed "shape" or changes constantly, a SQL schema (which requires a migration for every change) becomes a bottleneck.
    When: When you are ingesting data from various third-party APIs, IoT sensors, or user-generated content where the fields vary from one record to the next.

C. High Velocity / Low Latency
   SQL databases prioritize ACID compliance (guaranteeing every transaction is perfect), which adds overhead. NoSQL often prioritizes speed and availability.
   When: When it’s more important to show a "Like" count instantly than it is to ensure that count is 100% accurate down to the millisecond.

Adantages:
* NoSQL stores data as large JSON blobs, making insertions and retrievals efficient for entire records.
  Example: id, data. In data we will put json for all columns and relations also like {name: '', age: , profile: {}, }
* It offers flexible schema, allowing for easy addition of new attributes without expensive operations. No need to add another column in table what SQL(RDBMS) does.
* NoSQL databases are built for horizontal partitioning and are optimized for aggregations like maximum age.

Disadvatntages:
* Updation problem, Lack of inherent consistency (ACID properties), making them unsuitable for financial transactions.
* They are not read-optimized for specific column queries and lack implicit relations, making joins difficult 

The Four Major Types of NoSQL:
1. Document (e.g., MongoDB)	General purpose, content management, user profiles.	Storing a blog post with varying tags, comments, and metadata.
2. Key-Value (e.g., Redis)	Caching, session management, real-time leaderboards. Remembering that a user is logged in as they click through a site.
3. Wide-Column (e.g., Cassandra) Massive datasets, time-series data, high-write volume.	Storing billions of logs or sensor readings from smart devices.
4. Graph (e.g., Neo4j)	Social networks, fraud detection, recommendation engines. Mapping "Friends of Friends" or finding patterns in money laundering.

. Real-Life Use Cases & Who Uses Them
Netflix: Personalization & Availability
Netflix uses Cassandra for its high availability. When you're watching a show, the system needs to save your progress constantly. They can't afford for the database to go down, and since users are spread globally, they need a database that replicates data across different regions effortlessly.

Uber: Dynamic Data
Uber uses a variety of NoSQL stores (like Schemaless, built on MySQL/NoSQL principles) to handle the massive influx of GPS coordinates and trip data. Since trip details can change (different cities have different tax laws or vehicle types), a flexible schema is mandatory.

Amazon: The "Shopping Cart" Problem
Amazon created DynamoDB because during peak times (Prime Day), a relational database couldn't scale fast enough to handle every single person adding items to their carts. They needed a system that would never "lock" a table, ensuring the "Buy" button always works.

LinkedIn: The Social Graph
To show you "2nd-degree connections," a SQL database would have to perform massive, slow "JOIN" operations. LinkedIn uses graph-based logic to navigate these relationships instantly.

* Using Mysql and Nosql together:
In a polyglot architecture, your application doesn't talk to one giant database. Instead, different components or services talk to the database that suits their data structure.
Real-World Scenario: An E-commerce Platform

If you were designing a platform like Amazon, you wouldn't pick just one. You would use both based on the "demand" of the specific feature:
Use SQL for: The "Source of Truth"

    Feature: User Accounts, Orders, and Financial Transactions.
    Why: You need ACID compliance. If a user buys an item, you must ensure the money is deducted AND the inventory is updated at the same exact time. You cannot have "eventual consistency" here—it must be perfect.
    Database: PostgreSQL or MySQL.

Use NoSQL for: The "High Scale" Features

    Feature: Product Catalog & Search.
    Why: Different products have different attributes (a Laptop has RAM; a T-shirt has Size). NoSQL handles this flexible schema easily.
    Database: MongoDB or Elasticsearch.

Use NoSQL for: The "Speed" Features

    Feature: Shopping Cart & Session Management.
    Why: These are high-frequency, temporary bits of data. You need sub-millisecond latency so the site feels snappy.
    Database: Redis (Key-Value NoSQL).

When a change happens in your SQL database, it can emit an event that updates the NoSQL database using event driven architecture.

------------------------------------
NoSQL is a collection of data items represented in a key-value store, document store, wide column store, or a graph database. 
Data is denormalized, and joins are generally done in the application code. 
Most NoSQL stores lack true ACID transactions and favor eventual consistency.
BASE is often used to describe the properties of NoSQL databases:

    Basically available - the system guarantees availability.
    Soft state - the state of the system may change over time, even without input.
    Eventual consistency - the system will become consistent over a period of time, given that the system doesn't receive input during that period.

Reasons for SQL:

    Structured data
    Strict schema
    Relational data
    Need for complex joins
    Transactions
    Clear patterns for scaling
    More established: developers, community, code, tools, etc
    Lookups by index are very fast

Reasons for NoSQL:

    Semi-structured data
    Dynamic or flexible schema
    Non-relational data
    No need for complex joins
    Store many TB (or PB) of data
    Very data intensive workload
    Very high throughput for IOPS

Sample data well-suited for NoSQL:

    Rapid ingest of clickstream and log data
    Leaderboard or scoring data
    Temporary data, such as a shopping cart
    Frequently accessed ('hot') tables
    Metadata/lookup tables

The SQL vs. NoSQL debate has evolved beyond a binary choice. The line between these technologies continues to blur:

    SQL databases adopt NoSQL features: PostgreSQL now handles JSON documents, while CockroachDB and Google Spanner provide horizontal scaling.
    NoSQL databases incorporate SQL-like capabilities: MongoDB’s aggregation framework, Couchbase’s N1QL, and Cassandra’s CQL all provide SQL-inspired query options.
    Specialized databases target specific workloads like Search-optimized databases (Elasticsearch).

A hybrid model(Polyglot Persistence) works best when you need to handle a mix of transactional and high-throughput workloads.
Let's say in a microservice architecture:

    Order Processing Service: PostgreSQL for ACID-compliant transaction handling
    Product Catalog Service: MongoDB for flexible schema evolution and document querying
    User Activity Service: Cassandra for high-throughput event logging
    Search Service: Elasticsearch for advanced text search capabilities
    Caching Layer: Redis for ultra-fast access to frequently requested data
    For the support chat, use DynamoDB for real-time data. Users could send messages to each other in real-time, something that is much easier done than in MySQL.
    While the MySQL database stored user profiles, DynamoDB stored auth sessions, code.

Data Flow Example:

    Customer searches for “wireless headphones” → Elasticsearch handles the search
    Customer views product details → MongoDB serves the complete product information
    Customer places an order → PostgreSQL records the transaction with ACID guarantees

Usage of NoSQL examples:
- User click a movie and we store it to make recommendation algorithm.
- Social Media Feeds, NoSQL handles high-volume, high-velocity data. Graph databases (like Neo4j) are also used here to map the complex relationships between "friends," "likes," and "shares."
- Internet of Things (IoT) & Sensor Data
- When you're shopping online, your "cart" needs to be lightning-fast and highly available. If the database is slow, the customer leaves.