Caching improves page load times and can reduce the load on your servers and databases.
Putting a cache in front of a database can help absorb uneven loads and spikes in traffic.

Client Caching: Caches can be located on the client side (OS or browser), server side, or in a distinct cache layer.
CDN Caching: CDNs are considered a type of cache.
Web Server Caching: Web servers can also cache requests, returning responses without having to contact application servers.
Database Caching: Database usually includes some level of caching in a default configuration, optimized for a generic use case. 
Application Caching: In-memory caches such as Memcached and Redis are key-value stores between your application and your data storage.
Since the data is held in RAM, it is much faster than typical databases where data is stored on disk.
RAM is more limited than disk, so cache invalidation algorithms such as least recently used (LRU) can help invalidate 'cold' entries and keep 'hot' data in RAM.

We can cache database queries and objects:
    Row level
    Query-level
    Fully-formed serializable objects
    Fully-rendered HTML
 Avoid file-based caching, as it makes cloning and auto-scaling more difficult.

Caching at Database Level: Whenever you query the database, hash the query as a key and store the result to the cache. 
Caching at Object Level: Remove the object from cache if its underlying data has changed, Allows for asynchronous processing: workers assemble objects by consuming the latest cached object
Exmp: User sessions, fully rendered web pages, activity streams, user graph data.

Write through: The application uses the cache as the main data store, reading and writing data to it, while the cache is responsible for reading and writing to the database

    Application adds/updates entry in cache
    Cache synchronously writes entry to data store
    Return
Write-through is a slow overall operation due to the write operation, but subsequent reads of just written data are fast.

Write Behind:

    Add/update entry in cache
    Asynchronously write entry to the data store, improving write performance

Refresh Ahead: Can configure the cache to automatically refresh any recently accessed cache entry prior to its expiration.
Refresh-ahead can result in reduced latency vs read-through if the cache can accurately predict which items are likely to be needed in the future.

Disadvatages of Cache:
Need to maintain consistency between caches and the source of truth such as the database through cache invalidation.
Cache invalidation is a difficult problem, there is additional complexity associated with when to update the cache.
Need to make application changes such as adding Redis or memcached.

